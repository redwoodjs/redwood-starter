import { HttpError } from '../errors.mjs';
import { DEFAULT_TRANSFORM_RESULT_FN } from './utils.mjs';
export function getRegularResponse(responseResult, Response, transformResult = DEFAULT_TRANSFORM_RESULT_FN) {
    const headersInit = [];
    for (const { name, value } of responseResult.headers) {
        headersInit.push([name, value]);
    }
    const responseInit = {
        headers: headersInit,
        status: responseResult.status,
    };
    const transformedResult = transformResult(responseResult.payload);
    const responseBody = JSON.stringify(transformedResult);
    return new Response(responseBody, responseInit);
}
export function getMultipartResponse(multipartResult, Response, ReadableStream, transformResult = DEFAULT_TRANSFORM_RESULT_FN) {
    const headersInit = {
        "Connection": "keep-alive",
        "Content-Type": 'multipart/mixed; boundary="-"',
        "Transfer-Encoding": "chunked",
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    const readableStream = new ReadableStream({
        async start(controller) {
            controller.enqueue(`---`);
            await multipartResult.subscribe(patchResult => {
                const transformedResult = transformResult(patchResult);
                const chunk = JSON.stringify(transformResult(transformedResult));
                const data = ["", "Content-Type: application/json; charset=utf-8", "Content-Length: " + String(chunk.length), "", chunk];
                if (patchResult.hasNext) {
                    data.push("---");
                }
                controller.enqueue(data.join("\r\n"));
            });
            controller.enqueue('\r\n-----\r\n');
            controller.close();
        }
    });
    return new Response(readableStream, responseInit);
}
export function getPushResponse(pushResult, Response, ReadableStream, transformResult = DEFAULT_TRANSFORM_RESULT_FN) {
    const headersInit = {
        "Content-Type": "text/event-stream",
        "Connection": "keep-alive",
        "Cache-Control": "no-cache",
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    const readableStream = new ReadableStream({
        async start(controller) {
            await pushResult.subscribe(result => {
                controller.enqueue(`data: ${JSON.stringify(transformResult(result))}\n\n`);
            });
            controller.close();
        }
    });
    return new Response(readableStream, responseInit);
}
export function getResponse(result, Response, ReadableStream, transformResult = DEFAULT_TRANSFORM_RESULT_FN) {
    switch (result.type) {
        case "RESPONSE":
            return getRegularResponse(result, Response, transformResult);
        case "MULTIPART_RESPONSE":
            return getMultipartResponse(result, Response, ReadableStream, transformResult);
        case "PUSH":
            return getPushResponse(result, Response, ReadableStream, transformResult);
        default:
            throw new HttpError(500, "Cannot process result.");
    }
}
